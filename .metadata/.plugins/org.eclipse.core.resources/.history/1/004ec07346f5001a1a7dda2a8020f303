package uno;

import java.util.Collections;


public class Actions  {
	GameState currentGame;
	public Actions(GameState game) {
		currentGame = game;
	};
	
	
	public void reverse_card_Played() {
		this.currentGame.current_direction *= -1;
	}
	
	public void skip_card_Played() {
		this.currentGame.nextPlayer = null;
	}
	
	public void draw_two_card_played() {
		
	}
	
	public void wild_card_played() {
		
	}
	
	public void wild_draw_4_played() {
		
	}

	public void create_and_distribute_cards() {
		
	}
	
	public Deck create_playableDeck() {
		return null;
	}
	
	
	
	//Shuffle the discard pile to be used as the playable deck when the playable deck runs out
	public Deck shuffle_discard(Deck deck_to_shuffle) {
		Collections.shuffle(deck_to_shuffle.getDeck());
		return deck_to_shuffle;
	}
	
	//Replace the playable deck with the shuffled discard pile
	public Deck discard_to_playable(Deck previous_discard_deck) {
		Deck prev_playableDeck = this.currentGame.playableDeck;
		this.currentGame.playableDeck = previous_discard_deck;
		this.currentGame.discardDeck = prev_playableDeck;
		return this.currentGame.playableDeck;
	}
	
	//Any time a card is taken from the deck, it need to be popped and into the players hand
	public void subtract_from_playable_deck() {
		this.currentGame.playableDeckCount -= 1;
		//check if the playableDeck is empty, if yes, then make discard deck new playable deck
		if(this.currentGame.playableDeckCount == 0) {
			Deck newDeck = shuffle_discard(this.currentGame.playableDeck);
			this.currentGame.playableDeck = discard_to_playable(newDeck);
		}
	}
	
	//playable deck should be updated after a card is drawn. card should be taken out. count should be decreased
	public Card pull_from_playable_deck() {
		Card current = this.currentGame.playableDeck.pop();
		this.subtract_from_playable_deck();
		return current;
	}
}
